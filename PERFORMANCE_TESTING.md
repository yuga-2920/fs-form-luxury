# パフォーマンステストガイド

## 概要

このプロジェクトでは、`tinybench`を使用してパフォーマンステストを実装しています。主要なモジュールの実行速度とメモリ使用量を監視し、パフォーマンスの低下を防いでいます。

## セットアップ

```bash
npm install -D tinybench @vitest/browser
```

## パフォーマンステストの実行

```bash
# パフォーマンステストのみ実行
npm test -- src/modules/__tests__/performance.test.js

# 通常のテストと一緒に実行
npm test
```

## テスト対象モジュール

### 1. Utils モジュール
- **debounce**: 高頻度呼び出し時のパフォーマンス
  - 基準: 平均実行時間 < 5ms
  - 1000回の連続呼び出しでも効率的に動作

- **throttle**: 高頻度呼び出し時のパフォーマンス
  - 基準: 平均実行時間 < 5ms
  - 適切な間隔で関数を実行

- **deepClone**: 深いネストを持つオブジェクトのクローン
  - 基準: 平均実行時間 < 1ms
  - 複雑なオブジェクト構造でも高速

- **parseQueryString**: 大量のクエリパラメータの解析
  - 基準: 平均実行時間 < 2ms
  - 100個のパラメータでも高速処理

### 2. FormValidator モジュール
- **validateEmail**: 複数のメールアドレス検証
  - 基準: 平均実行時間 < 0.1ms
  - 正規表現による効率的な検証

- **validateForm**: 大規模フォームの検証
  - 基準: 平均実行時間 < 5ms
  - 50個のフィールドを持つフォームでも高速

### 3. ImageMapping モジュール
- **getAvoidItemImage**: 画像マッピングの検索
  - 基準: 平均実行時間 < 0.05ms
  - O(1)の高速検索

- **getAttractiveStyleImage**: 大量の画像検索
  - 基準: 平均実行時間 < 1ms
  - 150個の画像パスの一括検索でも高速

### 4. LocalStorage モジュール
- **saveFormData**: 大規模フォームデータの保存
  - 基準: 平均実行時間 < 2ms
  - 100フィールドのデータでも高速保存

- **restoreFormData**: 大規模データの復元
  - 基準: 平均実行時間 < 3ms
  - DOM操作を含めても高速

## メモリ使用量テスト

### メモリリークの検出
- **debounce**: 1000個の関数作成後のメモリ増加量
  - 基準: < 10MB
  - 適切なクリーンアップの確認

- **deepClone**: 大規模オブジェクトのクローン
  - 基準: < 50MB (元のオブジェクトの10倍程度)
  - メモリ効率的なクローン実装

## パフォーマンス基準の設定

### 基準値の決定方法
1. **ユーザー体験**: 人間が遅延を感じない範囲（通常50ms以下）
2. **競合比較**: 同様の機能を持つライブラリとの比較
3. **実環境**: 実際の使用環境でのテスト結果

### 基準値の例
```javascript
// 高速な操作（マイクロ秒単位）
expect(result.mean).toBeLessThan(0.1); // 0.1ms以下

// 通常の操作（ミリ秒単位）
expect(result.mean).toBeLessThan(5); // 5ms以下

// 複雑な操作（数ミリ秒）
expect(result.mean).toBeLessThan(10); // 10ms以下
```

## ベストプラクティス

### 1. ベンチマークの設定
```javascript
const bench = new Bench({ 
  time: 100,  // 最小実行時間（ミリ秒）
  iterations: 1000  // 最小イテレーション数
});
```

### 2. ウォームアップ
```javascript
// ベンチマーク前にウォームアップ実行
for (let i = 0; i < 10; i++) {
  targetFunction();
}
```

### 3. 統計的有意性
- 複数回の実行で安定した結果を確認
- 外れ値の影響を最小化
- 平均値と中央値の両方を確認

### 4. 環境の影響を考慮
- CI環境と開発環境での差異
- ブラウザによる違い
- システムリソースの状態

## パフォーマンス改善のヒント

### 1. 計算の最適化
- 不要な計算を避ける
- メモ化（memoization）の活用
- 早期リターンの実装

### 2. DOM操作の最適化
- バッチ更新
- DocumentFragmentの使用
- 仮想DOMの検討

### 3. メモリ管理
- 不要な参照の削除
- イベントリスナーの適切な削除
- WeakMapやWeakSetの活用

## CI/CDでの活用

### GitHub Actionsでの実行
```yaml
- name: Run Performance Tests
  run: npm test -- src/modules/__tests__/performance.test.js
  
- name: Check Performance Regression
  run: |
    # パフォーマンステストの結果を保存・比較
    # 基準値を超えた場合はビルドを失敗させる
```

### パフォーマンスレポート
- ベンチマーク結果の可視化
- 時系列でのパフォーマンス推移
- プルリクエストでの比較

## トラブルシューティング

### テストが不安定な場合
1. **実行時間を増やす**
   ```javascript
   const bench = new Bench({ time: 500 }); // 500msに増加
   ```

2. **環境を安定させる**
   - 他のプロセスを停止
   - ブラウザの拡張機能を無効化
   - 開発者ツールを閉じる

3. **基準値の調整**
   - 環境に応じた現実的な値に設定
   - CI環境用の別基準を設定

### メモリテストが失敗する場合
- ガベージコレクションのタイミング
- `performance.memory`のサポート確認
- メモリプロファイラーの使用

## 今後の拡張

1. **ビジュアルパフォーマンス**
   - レンダリング速度の測定
   - アニメーションのFPS計測

2. **ネットワークパフォーマンス**
   - API呼び出しの速度
   - データ転送量の最適化

3. **バンドルサイズ**
   - コードサイズの監視
   - Tree-shakingの効果測定